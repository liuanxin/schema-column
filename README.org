
** 说明

由前端定义要返回的表字段及查询参数, 减少后端处理 sql 查询组装数据的代码量

** 使用

添加引用
#+BEGIN_SRC xml
<dependency>
    <groupId>com.github.liuanxin</groupId>
    <artifactId>table-column</artifactId>
    <version>0.0.1</version>
</dependency>
#+END_SRC

添加配置
#+BEGIN_SRC java
@Configuration
public class TableColumnConfig {

    // 表关联
    @Bean("tableRelationList")
    public List<TableColumnRelation> tableRelation() {
        return List.of(
                // 主表表名, 主表字段, 跟子表的关系(一对一, 一对多, 多对多), 子表表名, 子表字段
                new TableColumnRelation("t_order", "order_no", TableRelationType.ONE_TO_ONE, "t_order_address", "order_no"),
                new TableColumnRelation("t_order", "order_no", TableRelationType.ONE_TO_MANY, "t_order_log", "order_no")
        );
    }

    // 查询别名
    @Bean("queryAliasMap")
    public Map<String, ReqAlias> queryAlias() {
        return Map.of(
                // 用这个查询别名时, 只有订单表(所有字段)
                "all-order", new ReqAlias("Order"),

                "order-address-item-log", orderAddressItemLogAlias()
        );
    }

    private ReqAlias orderAddressItemLogAlias() {
        // 指定 订单表 的字段, 指定 订单地址表 订单项表 订单日志表 的字段, 查询 Order 时 distinct, 并指定查询时多张表之间的关联方式
        ReqResult result = new ReqResult(List.of(
                "orderNo", "orderStatus", "amount", "desc", "createTime",
                Map.of("address", Map.of("table", "OrderAddress", "columns", List.of("contact", "phone", "address"))),
                Map.of("items", Map.of("table", "OrderItem", "columns", List.of("productName", "price", "number"))),
                Map.of("logs", Map.of("table", "OrderLog", "columns", List.of("operator", "message", "time")))
        ), true);
        List<List<String>> relationList = List.of(List.of("Order", "inner", "OrderAddress"), List.of("Order", "left", "OrderItem"));
        return new ReqAlias("Order", result, relationList);
    }
}
#+END_SRC

添加以下 mapping
#+BEGIN_SRC java
@RestController
@RequiredArgsConstructor
public class TableColumnController {

    private final TableColumnTemplate tableColumnTemplate;

    @GetMapping("/table-column")
    public List<QueryInfo> info(String tables) {
        return tableColumnTemplate.info(tables);
    }

    @PostMapping("/table-column")
    public Object query(@RequestBody ReqInfo req) {
        return tableColumnTemplate.dynamicQuery(req);
    }
}
#+END_SRC

相关的配置中下
#+BEGIN_SRC yaml
query:
  # 存放关联表的类的包地址, 多个用英文逗号隔开.
  scan-packages:
  # 当关联表的类上没有标注解, 将类名转换成表名时, 表的前缀.
  table-prefix:
  # 设置为 true 时查询关联信息将返回空, 默认是 false.
  has-not-return-info:
  # 设置为 true 时, 查询只能使用别名, 默认是 false.
  required-alias:
  # 设置为 true 时, 查询可以不需要有条件或分页, 默认是 false.
  not-required-condition-or-page:
  # 表名 字段名 别名生成的规则(比如表名是 t_user_info, 字段是 user_name):
  #   Standard(表 UserInfo  字段 userName, 不设置则默认是此值)
  #   Horizontal(表 User-Info  字段 user-name)
  #   Under(表 User_Info  字段 user_name)
  #   Letter(表 A-B...Z-AA...ZZ  字段 a-b...z-aa...zz)
  #   Same(一致)
  #   Lower(小写)
  #   Upper(大写)
  alias-generate-rule:
  # 当要请求的数据页(page * limit)大于当前值时, sql 查询将会拆分成 2 条, 先只查 id 再用 id 查具体的数据, 默认是 10000.
  deep-max-page-size:
  # 查询条件是集合时的最大个数, 默认是 1000.
  max-list-count:
  # 当表与表之间是一对一关联, 但查询时数据却出现了多条时的处理: Exception(抛出异常, 此为默认), First(以前面的为准), Cover(后面覆盖前面).
  one-to-one-has-many-rule:
  # 用来做逻辑删除的字段名, 标了 @LogicInfo 注解则以注解所在字段为主.
  logic-delete-column:
  # 用来做逻辑删除的默认值, 比如设置成 0, 表中有字段标了 @LogicDelete 则以注解为主.
  logic-value:
  # 用来做逻辑删除的字段类型是 tinyint(1) 时的删除值, 比如设置成 1, 表中有字段标了 @LogicDelete 则以注解为主.
  logic-delete-boolean-value:
  # 用来做逻辑删除的字段类型是 int 时的删除值, 比如设置成 UNIX_TIMESTAMP(), 表中有字段标了 @LogicDelete 则以注解为主.
  logic-delete-int-value:
  # 用来做逻辑删除的字段类型是 bigint 时的值, 比如设置成 id, 表中有字段标了 @LogicDelete 则以注解为主.
  logic-delete-long-value:
#+END_SRC
