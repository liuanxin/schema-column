
** 说明

在接口入参中定义查询参数及返回结果, *无需编写后端代码*, 自动处理数据查询并组装数据

** 使用

添加引用
#+BEGIN_SRC xml
<dependency>
    <groupId>com.github.liuanxin</groupId>
    <artifactId>table-column</artifactId>
    <version>0.0.1</version>
</dependency>
#+END_SRC

添加配置
#+BEGIN_SRC java
@Configuration
public class TableColumnConfig {

    /** 设置表关联关系 */
    @Bean
    public List<TableColumnRelation> tableRelationList() {
        // return new ArrayList<>();
        return Arrays.asList(
                // 主表表名, 主表字段, 跟子表的关系(一对一, 一对多, 多对多), 子表表名, 子表字段
                new TableColumnRelation("t_order", "order_no", TableRelationType.ONE_TO_ONE, "t_order_address", "order_no"),
                new TableColumnRelation("t_order", "order_no", TableRelationType.ONE_TO_ONE, "t_order_item", "order_no"),
                new TableColumnRelation("t_order", "order_no", TableRelationType.ONE_TO_MANY, "t_order_log", "order_no")
        );
    }

    /** 设置查询别名 */
    @Bean
    public Map<String, ReqAlias> queryAliasMap() {
        Map<String, ReqAlias> aliasMap = new HashMap<>();
        aliasMap.put("all-order", new ReqAlias("Order"));
        aliasMap.put("order-address-item-log", orderAddressItemLogAlias());
        return aliasMap;
    }

    private ReqAlias orderAddressItemLogAlias() {
        // 指定 订单表 的字段, 指定 订单地址表 订单项表 订单日志表 的字段, 查询 Order 时 distinct, 并指定查询时多张表之间的关联方式
        ReqResult result = new ReqResult(Arrays.asList(
                "orderNo", "orderStatus", "amount", "desc", "createTime",
                Map.of("address", Map.of("table", "OrderAddress", "columns", Arrays.asList("contact", "phone", "address"))),
                Map.of("items", Map.of("table", "OrderItem", "columns", Arrays.asList("productName", "price", "number"))),
                Map.of("logs", Map.of("table", "OrderLog", "columns", Arrays.asList("operator", "message", "time")))
        ), true);
        List<List<String>> relationList = Arrays.asList(Arrays.asList("Order", "inner", "OrderAddress"), Arrays.asList("Order", "left", "OrderItem"));
        return new ReqAlias("Order", result, relationList);
    }
}
#+END_SRC

添加以下 mapping
#+BEGIN_SRC java
@RestController
@RequiredArgsConstructor
public class TableColumnController {

    private final TableColumnTemplate tableColumnTemplate;

    @GetMapping("/table-column")
    public List<QueryInfo> info(String tables) {
        return tableColumnTemplate.info(tables);
    }

    @PostMapping("/table-column")
    public Object query(@RequestBody ReqInfo req) {
        return tableColumnTemplate.dynamicQuery(req);
    }
}
#+END_SRC

相关的配置中下
#+BEGIN_SRC yaml
query:
  # 存放关联表的类的包地址, 多个用英文逗号隔开.
  scan-packages:
  # 当关联表的类上没有标注解, 将类名转换成表名时, 表的前缀(比如 t_ 开头).
  table-prefix:
  # 设置为 true 时查询表及字段信息将返回空, 比如只在生产环境设置成 true, 默认是 false.
  has-not-return-info:
  # 设置为 true 时, 查询只能使用别名, 默认是 false.
  required-alias:
  # 设置为 true 时, 查询可以不需要有条件或分页, 默认是 false.
  not-required-condition-or-page:
  # 表名 字段名 生成别名的规则(比如表名是 t_user_info, 字段是 user_name):
  #   Standard(表 UserInfo  字段 userName, 不设置则默认是此值)
  #   Horizontal(表 User-Info  字段 user-name)
  #   Under(表 User_Info  字段 user_name)
  #   Letter(表 A-B...Z-AA...ZZ  字段 a-b...z-aa...zz)
  #   Number(表 100001-100002..., 字段: 1-2...)
  #   Same(一致)
  #   Lower(小写)
  #   Upper(大写)
  alias-generate-rule:
  # 当要请求的分页数据(page * limit)大于当前值时, sql 查询将会拆分成 2 条, 先只查 id 再用 id 查具体的数据, 默认是 10000.
  deep-max-page-size:
  # 查询条件是集合时的最大个数, 默认是 1000.
  max-list-count:
  # 当表与表之间是一对一关联, 但查询时数据却出现了多条时的处理: Exception(抛出异常, 此为默认), First(以前面的为准), Cover(后面覆盖前面).
  one-to-one-has-many-rule:
  # 用来做逻辑删除的字段名, 标了 @LogicInfo 注解则以注解所在字段为主.
  logic-delete-column:
  # 用来做逻辑删除的默认值, 比如设置成 0, 实体上的字段标了 @LogicDelete 则以注解为主.
  logic-value:
  # 用来做逻辑删除的字段类型是 tinyint(1) 时的删除值, 比如设置成 1, 实体上的字段标了 @LogicDelete 则以注解为主.
  logic-delete-boolean-value:
  # 用来做逻辑删除的字段类型是 int 时的删除值, 比如设置成 UNIX_TIMESTAMP(), 实体上的字段标了 @LogicDelete 则以注解为主.
  logic-delete-int-value:
  # 用来做逻辑删除的字段类型是 bigint 时的值, 比如设置成 id, 实体上的字段标了 @LogicDelete 则以注解为主.
  logic-delete-long-value:
#+END_SRC

请求 ~GET /table-column~ 将会返回表及字段的结构数据(如果想要此接口不返回数据, 配置 ~query.has-not-return-info = true~ 即可), 比如
#+BEGIN_SRC json
[
  {
    "name": "Order",
    "desc": "订单",
    "columnList": [
      {
        "name": "id",
        "type": "Long"
      },
      {
        "name": "orderNo",
        "desc": "订单号",
        "type": "String",
        "writeRequired": true,
        "maxLength": 32
      },
      {
        "name": "orderStatus",
        "desc": "订单状态(0.用户已创建待支付, 1.用户已支付待商户发货, 2.商户已发货待用户签收, 3.用户已签收待确认完结, 4.已完结)",
        "type": "Integer"
      },
      {
        "name": "amount",
        "desc": "订单金额",
        "type": "BigDecimal"
      },
      {
        "name": "desc",
        "desc": "备注",
        "type": "String",
        "maxLength": 32
      },
      {
        "name": "createTime",
        "desc": "创建时间",
        "type": "Date"
      },
      {
        "name": "updateTime",
        "desc": "更新时间",
        "type": "Date"
      }
    ]
  },
  {
    "name": "OrderLog",
    "desc": "订单日志",
    "columnList": [
      {
        "name": "id",
        "type": "Long"
      },
      {
        "name": "orderNo",
        "desc": "订单号",
        "type": "String",
        "maxLength": 32,
        "relationTable": "Order",
        "relationColumn": "orderNo"
      },
      {
        "name": "operator",
        "desc": "操作人",
        "type": "String",
        "maxLength": 32
      },
      {
        "name": "message",
        "desc": "操作内容",
        "type": "String",
        "maxLength": 65535
      },
      {
        "name": "time",
        "desc": "创建时间",
        "type": "Date"
      }
    ]
  }
]
#+END_SRC

请求 ~POST /table-column~ 时, 将会自动处理数据查询并组装数据, 其入参示例如下
#+BEGIN_SRC json
{
  "table": "Order", /* 表名 */
  "param": {
    "query": {      /* 查询条件 */
      /* "operate": "下面的条件拼接时的表达式, 并且(and) 和 或者(or) 两种, 不设置则默认是 and.", */
      "conditions": [
        [ "orderNo", "nn(表达式, 见下面的说明)" ],      /* 无值 */
        [ "orderNo", "eq", "x" ],                    /* 单值(长度不能超过上面的 maxLength 值) */
        [ "orderStatus", "in", [ "0", "1", "2" ] ],  /* 多值(长度不能超过 query.max-list-count 设置的值) */
        [ "amount", "bet", [ "10", "1000.5" ] ],
        [ "OrderItem.productName", "fuzzy", "xx" ],  /* 子表 */
        [ "OrderLog.operator", "start", "xxx" ],     /* 子表 */
        {
          "operate": "or", /* 嵌套条件(用 AND 拼上面的条件, 用 OR 拼下面的条件) */
          "conditions": [
            [ "orderStatus", "eq", "3" ],
            [ "OrderLog.time", "bet", [ "2020-01-01" ] ]
          ]
        },
      ]
    },
    "sort": { "createTime": "desc",  "OrderLog.operator": "asc" },
    "page": [ 2, 20 ] /* 分页查询, 如果省略第 2 个参数如 [ 2 ] 则等同于 [ 2, 10 ] */
    "relation": [ [ "Order(主表)", "inner(连接类型, 有 left inner right 三种)", "OrderItem(子表)" ],  [ "Order", "inner", "OrderLog" ] ] # 当上面的 conditions 有多个表时需要
  },
  "result": {
    "columns": [
      "id", "orderNo", "orderStatus", "amount", "desc",
      { "createTime" : [ "yyyy-MM-dd HH:mm", "GMT+8" ] },  /* 格式化: [ "pattern", "timeZone" ], 默认是 yyyy-MM-dd HH:mm:ss */
      {
        "address(子表数据返回时的自定义属性名)": {
          "table": "OrderAddress",
          "columns": [ "contact", "address" ]
        }
      },
      {
        "items": {
          "table": "OrderItem",
          "columns": [ "productName", "price", "number" ]
        }
      },
      {
        "logs": {
          "table": "OrderLog",
          "columns": [ "operator", "message", "time" ]
        }
      }
    ],
    "distinct": true /* true 表示将查询数据去重, 不设置则默认是 false */
  }
}
#+END_SRC

最终会生成如下 ~sql~
#+BEGIN_SRC sql
/* 如果没有分页查询入参(page)则不会生成此 sql */
SELECT COUNT(DISTINCT `Order`.id)
FROM t_order `Order` INNER JOIN t_order_item OrderItem ON ... INNER JOIN t_order_log OrderLog ON ...
WHERE `Order`.orderNo IS NOT NULL AND `Order`.orderNo = 'x'
AND `Order`.order_status IN ( 0, 1, 2 ) AND `Order`.amount BETWEEN 10 AND 1000.5
AND OrderItem.product_name LIKE '%xx%' AND OrderLog.operator LIKE 'xx%'
AND ( `Order`.order_status = 3 OR OrderLog.time >= '2020-01-01' )


/* 如果没有分页查询入参(page)则不会有 LIMIT */
SELECT DISTINCT `Order`.id, `Order`.order_no, `Order`.order_status, `Order`.amount, `Order`.`desc`
FROM t_order `Order` INNER JOIN t_order_item OrderItem ON ... INNER JOIN t_order_log OrderLog ON ...
WHERE `Order`.orderNo IS NOT NULL AND `Order`.orderNo = 'x'
AND `Order`.order_status IN ( 0, 1, 2 ) AND `Order`.amount BETWEEN 10 AND 1000.5
AND OrderItem.product_name LIKE '%xx%' AND OrderLog.operator LIKE 'xx%'
AND ( `Order`.order_status = 3 OR OrderLog.time >= '2020-01-01' )
ORDER BY `Order`.create_time DESC, OrderLog.operator
LIMIT 10, 20


/* 下面的 xxx 和 yyy 由上面的查询而来, 如果量很大会分批查询, 单次查询的个数由 query.max-list-count 控制 */
SELECT order_no, contact, address
FROM t_order_address
WHERE order_no IN ( 'xxx', 'yyy' )


SELECT order_no, productName, price, number
FROM t_order_item
WHERE order_no IN ( 'xxx', 'yyy' )


SELECT order_no, operator, message, time
FROM t_order_log
WHERE order_no IN ( 'xxx', 'yyy' )
#+END_SRC

返回数据如下
#+BEGIN_SRC json
{
  "count": 123,
  "list": [
    {
      "id": 1234,
      "orderNo": "xx",
      "amount": "xxx",
      "desc": "xxxxxx",
      "createTime": "yyyy-MM-dd HH:mm",
      "address": {
        "contact": "y",
        "address": "yy"
      },
      "items": [
        {
          "productName": "z",
          "price": "10.5",
          "number": 2
        }
      ],
      "logs": [
        {
          "operator": "z",
          "message": "zz",
          "time": "yyyy-MM-dd HH:mm:ss"
        },
        {
          "operator": "zzz",
          "message": "zzzz",
          "time": "yyyy-MM-dd HH:mm"
        }
      ]
    },
    { ... }
  ]
}
#+END_SRC

表达式说明
#+BEGIN_EXAMPLE
nu     : IS NULL      为空
nn     : IS NOT NULL  不为空

eq     : =            等于
ne     : <>           不等于

in     : IN           包含
ni     : NOT IN       不包含

bet    : BETWEEN      区间
nbe    : NOT BETWEEN  不在区间

gt     : >            大于
ge     : >=           大于等于
lt     : <            小于
le     : <=           小于等于

fuzzy  : LIKE '%x%'     模糊
nfuzzy : NOT LIKE '%x%' 不模糊
start  : LIKE 'x%'      开头
nstart : NOT LIKE 'x%'  不开头
end    : LIKE '%x'      结尾
nend   : NOT LIKE '%x'  不结尾
#+END_EXAMPLE
