
** 说明
极大减少后端在实现查询 sql 时的代码量, 由前端来定义要返回的表字段及查询的参数, 当前解析器会拼接 sql 并以入参的返回形式组装数据最终返回

** 使用

添加引用
#+BEGIN_SRC xml
<dependency>
    <groupId>com.github.liuanxin</groupId>
    <artifactId>table-column</artifactId>
    <version>0.0.1</version>
</dependency>
#+END_SRC

添加配置
#+BEGIN_SRC java
@Configuration
public class TableColumnConfig {
    // 表关联
    @Bean("tableRelationList")
    public List<TableColumnRelation> tableRelation() {
        return List.of(
                // 主表表名, 主表字段, 跟子表的关系(一对一, 一对多, 多对多), 子表表名, 子表字段
                new TableColumnRelation("t_order", "order_no", TableRelationType.ONE_TO_ONE, "t_order_address", "order_no"),
                new TableColumnRelation("t_order", "order_no", TableRelationType.ONE_TO_MANY, "t_order_log", "order_no")
        );
    }

    // 查询别名
    @Bean("queryAliasMap")
    public Map<String, ReqAlias> queryAlias() {
        return Map.of(
                // 查询
                "all-order", new ReqAlias("Order"),

                "order-address-item-log", new ReqAlias("Order", new ReqResult(List.of(
                        "orderNo", "orderStatus", "amount", "desc", "createTime",
                        Map.of("address", Map.of("table", "OrderAddress", "columns", Arrays.asList("contact", "phone", "address"))),
                        Map.of("items", Map.of("table", "OrderItem", "columns", Arrays.asList("productName", "price", "number"))),
                        Map.of("logs", Map.of("table", "OrderLog", "columns", Arrays.asList("operator", "message", "time")))
                )))
        );
    }
}
#+END_SRC

添加以下 mapping
#+BEGIN_SRC java
@RestController
@RequiredArgsConstructor
public class TableColumnController {

    private final TableColumnTemplate tableColumnTemplate;

    @GetMapping("/table-column")
    public List<QueryInfo> info(String tables) {
        return tableColumnTemplate.info(tables);
    }

    @PostMapping("/table-column")
    public Object query(@RequestBody ReqInfo req) {
        return tableColumnTemplate.dynamicQuery(req);
    }
}
#+END_SRC

#+BEGIN_SRC yaml
# 相关的配置中下
query:
  # 存放关联表的类的包地址, 多个用英文逗号隔开.
  scan-packages:
  # 当关联表的类上没有标注解, 将类名转换成表名时, 表的前缀.
  table-prefix:
  # 设置为 true 时查询关联信息将返回空, 默认是 false.
  has-not-return-info:
  # 设置为 true 时, 查询只能使用别名, 默认是 false.
  required-alias:
  # 设置为 true 时, 查询可以不需要有条件或分页, 默认是 false.
  not-required-condition-or-page:
  # 别名生成的规则: Standard(表 UserInfo  字段 userName, 不设置则默认是此值), Horizontal(表 User-Info  字段 user-name),
  # Under(表 User_Info  字段 user_name), Letter(表 A-B...Z-AA...ZZ  字段 a-b...z-aa...zz), Same(一致), Lower(小写), Upper(大写).
  alias-generate-rule:
  # 当要请求的数据页(page * limit)大于当前值时, sql 查询将会拆分成 2 条, 先只查 id 再用 id 查具体的数据, 默认是 10000.
  deep-max-page-size:
  # 查询条件是集合时的最大个数, 默认是 1000.
  max-list-count:
  # 当表与表之间是一对一关联, 但查询时数据却出现了多条时的处理: Exception(抛出异常, 此为默认), First(以前面的为准), Cover(后面覆盖前面).
  one-to-one-has-many-rule:
  # 用来做逻辑删除的字段名, 标了 @LogicInfo 注解则以注解所在字段为主.
  logic-delete-column:
  # 用来做逻辑删除的默认值, 比如设置成 0, 表中有字段标了 @LogicDelete 则以注解为主.
  logic-value:
  # 用来做逻辑删除的字段类型是 tinyint(1) 时的删除值, 比如设置成 1, 表中有字段标了 @LogicDelete 则以注解为主.
  logic-delete-boolean-value:
  # 用来做逻辑删除的字段类型是 int 时的删除值, 比如设置成 UNIX_TIMESTAMP(), 表中有字段标了 @LogicDelete 则以注解为主.
  logic-delete-int-value:
  # 用来做逻辑删除的字段类型是 bigint 时的值, 比如设置成 id, 表中有字段标了 @LogicDelete 则以注解为主.
  logic-delete-long-value:
#+END_SRC
